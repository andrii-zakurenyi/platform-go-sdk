/*
 * Centrify Vault REST API
 *
 * Vault REST API specification
 *
 * API version: 1.0
 * Contact: support@centrify.com
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package secretinternal

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

type SecretsApi interface {

	/*
	 * Delete Delete a secret
	 * Deletes a secret from the vault.

	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param nameOrId The name or id of a secret. Note a name can be a path, and contained / characters should not be url encoded.
	 * @return ApiDeleteRequest
	 */
	Delete(ctx _context.Context, nameOrId string) ApiDeleteRequest

	/*
	 * DeleteExecute executes the request
	 */
	DeleteExecute(r ApiDeleteRequest) (*_nethttp.Response, error)

	/*
			 * Get Get secrets
			 * Gets a secret depending on the `{name}` path parameter.
		Does not include privileged data, see `/privilegeddata/secrets/{nameOrId}` path to retrieve privileged data.
		If {name} is the name of a folder of secrets, the results will only contain items that are direct descendants of the folder.

			 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			 * @param nameOrId The name or id of a secret. Note a name can be a path, and contained / characters should not be url encoded.
			 * @return ApiGetRequest
	*/
	Get(ctx _context.Context, nameOrId string) ApiGetRequest

	/*
	 * GetExecute executes the request
	 * @return SecretDense
	 */
	GetExecute(r ApiGetRequest) (SecretDense, *_nethttp.Response, error)

	/*
			 * Modify Modify a secret
			 * Modify a secret.

		Currently supports modifying a secret's privileged data.

		Note for a `bag` type secret, data is modified in its entirety.

			 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			 * @param nameOrId The name or id of a secret. Note a name can be a path, and contained / characters should not be url encoded.
			 * @return ApiModifyRequest
	*/
	Modify(ctx _context.Context, nameOrId string) ApiModifyRequest

	/*
	 * ModifyExecute executes the request
	 * @return SecretDense
	 */
	ModifyExecute(r ApiModifyRequest) (SecretDense, *_nethttp.Response, error)

	/*
			 * Retrieve Retrieve privileged data
			 * Retrieves the privileged data stored in the secret.

		## Required Roles
		- TODO

		## Required ACLs
		- retrieve
		- read

			 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			 * @param nameOrId The name or id of a secret. Note a name can be a path, and contained / characters should not be url encoded.
			 * @return ApiRetrieveRequest
	*/
	Retrieve(ctx _context.Context, nameOrId string) ApiRetrieveRequest

	/*
	 * RetrieveExecute executes the request
	 * @return PrivilegedData
	 */
	RetrieveExecute(r ApiRetrieveRequest) (PrivilegedData, *_nethttp.Response, error)

	/*
	 * SecretsCreate Create a secret
	 * Creates a secret

	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiSecretsCreateRequest
	 */
	SecretsCreate(ctx _context.Context) ApiSecretsCreateRequest

	/*
	 * SecretsCreateExecute executes the request
	 * @return SecretDense
	 */
	SecretsCreateExecute(r ApiSecretsCreateRequest) (SecretDense, *_nethttp.Response, error)

	/*
			 * SecretsList List secrets
			 * Returns a list of sparse secrets.

		Optionally use the limit, orderBy, filter or search parameters to control the results.

		`Note` all responses are paged by default. The response contains a `previous_url` and `next_url` to access the next or previous page of the list.

			 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			 * @return ApiSecretsListRequest
	*/
	SecretsList(ctx _context.Context) ApiSecretsListRequest

	/*
	 * SecretsListExecute executes the request
	 * @return SecretList
	 */
	SecretsListExecute(r ApiSecretsListRequest) (SecretList, *_nethttp.Response, error)
}

// SecretsApiService SecretsApi service
type SecretsApiService service

type ApiDeleteRequest struct {
	ctx        _context.Context
	ApiService SecretsApi
	nameOrId   string
}

func (r ApiDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteExecute(r)
}

/*
 * Delete Delete a secret
 * Deletes a secret from the vault.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param nameOrId The name or id of a secret. Note a name can be a path, and contained / characters should not be url encoded.
 * @return ApiDeleteRequest
 */
func (a *SecretsApiService) Delete(ctx _context.Context, nameOrId string) ApiDeleteRequest {
	return ApiDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

/*
 * Execute executes the request
 */
func (a *SecretsApiService) DeleteExecute(r ApiDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecretsApiService.Delete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secrets/{nameOrId}"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", _neturl.PathEscape(parameterToString(r.nameOrId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if strlen(r.nameOrId) < 1 {
		return nil, reportError("nameOrId must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v ModelError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetRequest struct {
	ctx        _context.Context
	ApiService SecretsApi
	nameOrId   string
}

func (r ApiGetRequest) Execute() (SecretDense, *_nethttp.Response, error) {
	return r.ApiService.GetExecute(r)
}

/*
 * Get Get secrets
 * Gets a secret depending on the `{name}` path parameter.
Does not include privileged data, see `/privilegeddata/secrets/{nameOrId}` path to retrieve privileged data.
If {name} is the name of a folder of secrets, the results will only contain items that are direct descendants of the folder.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param nameOrId The name or id of a secret. Note a name can be a path, and contained / characters should not be url encoded.
 * @return ApiGetRequest
*/
func (a *SecretsApiService) Get(ctx _context.Context, nameOrId string) ApiGetRequest {
	return ApiGetRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

/*
 * Execute executes the request
 * @return SecretDense
 */
func (a *SecretsApiService) GetExecute(r ApiGetRequest) (SecretDense, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SecretDense
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecretsApiService.Get")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secrets/{nameOrId}"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", _neturl.PathEscape(parameterToString(r.nameOrId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if strlen(r.nameOrId) < 1 {
		return localVarReturnValue, nil, reportError("nameOrId must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v ModelError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModifyRequest struct {
	ctx             _context.Context
	ApiService      SecretsApi
	nameOrId        string
	secretPatchable SecretMarshaler
}

func (r ApiModifyRequest) SecretPatchable(secretPatchable SecretMarshaler) ApiModifyRequest {
	r.secretPatchable = secretPatchable
	return r
}

func (r ApiModifyRequest) Execute() (SecretDense, *_nethttp.Response, error) {
	return r.ApiService.ModifyExecute(r)
}

/*
 * Modify Modify a secret
 * Modify a secret.

Currently supports modifying a secret's privileged data.

Note for a `bag` type secret, data is modified in its entirety.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param nameOrId The name or id of a secret. Note a name can be a path, and contained / characters should not be url encoded.
 * @return ApiModifyRequest
*/
func (a *SecretsApiService) Modify(ctx _context.Context, nameOrId string) ApiModifyRequest {
	return ApiModifyRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

/*
 * Execute executes the request
 * @return SecretDense
 */
func (a *SecretsApiService) ModifyExecute(r ApiModifyRequest) (SecretDense, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SecretDense
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecretsApiService.Modify")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secrets/{nameOrId}"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", _neturl.PathEscape(parameterToString(r.nameOrId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if strlen(r.nameOrId) < 1 {
		return localVarReturnValue, nil, reportError("nameOrId must have at least 1 elements")
	}
	if r.secretPatchable == nil {
		return localVarReturnValue, nil, reportError("secretPatchable is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.secretPatchable
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v ModelError
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRetrieveRequest struct {
	ctx        _context.Context
	ApiService SecretsApi
	nameOrId   string
}

func (r ApiRetrieveRequest) Execute() (PrivilegedData, *_nethttp.Response, error) {
	return r.ApiService.RetrieveExecute(r)
}

/*
 * Retrieve Retrieve privileged data
 * Retrieves the privileged data stored in the secret.

## Required Roles
- TODO

## Required ACLs
- retrieve
- read

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param nameOrId The name or id of a secret. Note a name can be a path, and contained / characters should not be url encoded.
 * @return ApiRetrieveRequest
*/
func (a *SecretsApiService) Retrieve(ctx _context.Context, nameOrId string) ApiRetrieveRequest {
	return ApiRetrieveRequest{
		ApiService: a,
		ctx:        ctx,
		nameOrId:   nameOrId,
	}
}

/*
 * Execute executes the request
 * @return PrivilegedData
 */
func (a *SecretsApiService) RetrieveExecute(r ApiRetrieveRequest) (PrivilegedData, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PrivilegedData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecretsApiService.Retrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/privilegeddata/secrets/{nameOrId}"
	localVarPath = strings.Replace(localVarPath, "{"+"nameOrId"+"}", _neturl.PathEscape(parameterToString(r.nameOrId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if strlen(r.nameOrId) < 1 {
		return localVarReturnValue, nil, reportError("nameOrId must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecretsCreateRequest struct {
	ctx            _context.Context
	ApiService     SecretsApi
	secretWritable SecretMarshaler
}

func (r ApiSecretsCreateRequest) SecretWritable(secretWritable SecretMarshaler) ApiSecretsCreateRequest {
	r.secretWritable = secretWritable
	return r
}

func (r ApiSecretsCreateRequest) Execute() (SecretDense, *_nethttp.Response, error) {
	return r.ApiService.SecretsCreateExecute(r)
}

/*
 * SecretsCreate Create a secret
 * Creates a secret

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSecretsCreateRequest
 */
func (a *SecretsApiService) SecretsCreate(ctx _context.Context) ApiSecretsCreateRequest {
	return ApiSecretsCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return SecretDense
 */
func (a *SecretsApiService) SecretsCreateExecute(r ApiSecretsCreateRequest) (SecretDense, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SecretDense
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecretsApiService.SecretsCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secrets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.secretWritable == nil {
		return localVarReturnValue, nil, reportError("secretWritable is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.secretWritable
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecretsListRequest struct {
	ctx        _context.Context
	ApiService SecretsApi
	limit      *int32
	orderBy    *[]string
	search     *string
	filter     *string
}

func (r ApiSecretsListRequest) Limit(limit int32) ApiSecretsListRequest {
	r.limit = &limit
	return r
}
func (r ApiSecretsListRequest) OrderBy(orderBy []string) ApiSecretsListRequest {
	r.orderBy = &orderBy
	return r
}
func (r ApiSecretsListRequest) Search(search string) ApiSecretsListRequest {
	r.search = &search
	return r
}
func (r ApiSecretsListRequest) Filter(filter string) ApiSecretsListRequest {
	r.filter = &filter
	return r
}

func (r ApiSecretsListRequest) Execute() (SecretList, *_nethttp.Response, error) {
	return r.ApiService.SecretsListExecute(r)
}

/*
 * SecretsList List secrets
 * Returns a list of sparse secrets.

Optionally use the limit, orderBy, filter or search parameters to control the results.

`Note` all responses are paged by default. The response contains a `previous_url` and `next_url` to access the next or previous page of the list.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSecretsListRequest
*/
func (a *SecretsApiService) SecretsList(ctx _context.Context) ApiSecretsListRequest {
	return ApiSecretsListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return SecretList
 */
func (a *SecretsApiService) SecretsListExecute(r ApiSecretsListRequest) (SecretList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SecretList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecretsApiService.SecretsList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/secrets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.orderBy != nil {
		localVarQueryParams.Add("orderBy", parameterToString(*r.orderBy, "csv"))
	}
	if r.search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("filter", parameterToString(*r.filter, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
